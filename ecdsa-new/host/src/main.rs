// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    ECDSA_NEW_TEST_ELF, ECDSA_NEW_TEST_ID
};
// use risc0_zkvm::{default_prover, ExecutorEnv};
use risc0_zkvm::{get_prover_server, ExecutorEnv, ProverOpts};

use k256::{
    ecdsa::{signature::Signer, Signature, SigningKey},
    EncodedPoint,
};
use rand_core::OsRng;
use std::time::{Instant};
use std::mem::size_of;

fn print_size<T>(_: &T) {
    let size = size_of::<T>();
    println!("Size of type: {} bytes", size);
}

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    let _num_sig = 5u32;
    let message = b"This is a message that will be signed, and verified within the zkVM";
    
    let mut _signatures: Vec<(EncodedPoint, Vec<u8>, Signature)> = Vec::new();

    let mut csprng = OsRng;

    for i in 0.._num_sig {
        let test_signing_key: SigningKey = SigningKey::random(&mut csprng);
        let mut test_message = message.to_vec();
        test_message.extend_from_slice(format!("-{}", i).as_bytes());
        let test_signature: Signature = test_signing_key.sign(&test_message);
        // let test_verifying_key: EncodedPoint = test_signing_key.verifying_key().to_encoded_point(true);

        _signatures.push((test_signing_key.verifying_key().to_encoded_point(true), test_message, test_signature));
    }

    println!("**********************************");
    println!("Generated examples: {:?}", _signatures);
    println!("**********************************");

    // For example:
    // let input: u32 = 15 * u32::pow(2, 27) + 1;
    let input = _signatures;

    println!("**********************************");
    println!("Generating proof receipt now");
    let start_proof = Instant::now();

    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    // let prover = default_prover();
    let prover = get_prover_server(&ProverOpts::succinct()).unwrap();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove(env, ECDSA_NEW_TEST_ELF)
        .unwrap();
    
    println!("The prove_info size is:");
    print_size(&prove_info);
    println!("{:?}", prove_info.stats);

    // extract the receipt.
    let receipt = prove_info.receipt;

    let end_proof = Instant::now();
    let elapsed_proof = end_proof - start_proof;
    println!("Generating proof done");
    println!("**********************************");

    let proof_bytes = receipt.inner.succinct().unwrap().get_seal_bytes().len();
    println!("The proof size is: {:?}", proof_bytes);

    // Print proof size
    // let proof_size = receipt.inner.composite().unwrap().segments.iter().fold(0, |acc, segment| acc + segment.get_seal_bytes().len());
    // println!("Proof size is {:?}", proof_size);
    // print_size(&receipt);

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    // let _output: u32 = receipt.journal.decode().unwrap();
    let _output: bool = receipt.journal.decode().unwrap();

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    println!("**********************************");
    println!("Verifying proof receipt now");
    let start_verify = Instant::now();

    receipt
        .verify(ECDSA_NEW_TEST_ID)
        .unwrap();
    
    let end_verify = Instant::now();
    let elapsed_verify = end_verify - start_verify;
    println!("Verifying proof done");
    println!("**********************************");

    println!("\nThe output is {:?}", _output);
    println!("Elapsed time for proof generation: {:?}", elapsed_proof);
    println!("Elapsed time for proof verification: {:?}", elapsed_verify);
}
