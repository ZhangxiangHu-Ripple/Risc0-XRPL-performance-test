// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    SHA512_HALF_TEST_ELF, SHA512_HALF_TEST_ID
};
// use risc0_zkvm::{default_prover, ExecutorEnv};
use risc0_zkvm::{get_prover_server, ExecutorEnv, ProverOpts};

use std::mem::size_of;
// use sha2::{Digest, Sha512};
// use std::any::type_name;
use std::time::{Instant};
// use std::mem;

fn print_size<T>(_: &T) {
    let size = size_of::<T>();
    println!("Size of type: {} bytes", size);
}

// fn print_type_of<T>(_: &T) {
//     println!("Type: {}", type_name::<T>());
// }

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    let base_message = "test data";
    let num_hash = 1u32;

    // let digest = Sha512::digest(&base_message.as_bytes());
    // let truncated_bytes = &digest[..32];
    // let hex_digest = hex::encode(truncated_bytes);

    // println!("**********************************");
    // println!("Print related input info...");
    // println!("Digest: {:?}", digest);
    // println!("Digest: {:?}", hex_digest);
    // println!("Truncated bytes: {:?}", truncated_bytes);
    // print_type_of(&hex_digest);
    // print_type_of(&truncated_bytes);

    let mut input_str: Vec<String> = Vec::new();

    for i in 0..num_hash {
        let test_message = format!("{}{}", base_message, i);

        input_str.push(test_message);
        
    }
    println!("Input value: {:?}", input_str);

    // For example:
    // let input: u32 = 15 * u32::pow(2, 27) + 1;
    let input = input_str;

    println!("**********************************");
    println!("Generating proof receipt now");
    let start_proof = Instant::now();
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    // let prover = default_prover();
    let prover = get_prover_server(&ProverOpts::succinct()).unwrap();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove(env, SHA512_HALF_TEST_ELF)
        .unwrap();

    println!("The prove_info size is:");
    print_size(&prove_info);
    println!("{:?}", prove_info.stats);

    // extract the receipt.
    let receipt = prove_info.receipt;

    let proof_bytes = receipt.inner.succinct().unwrap().get_seal_bytes().len();
    println!("The proof size is: {:?}", proof_bytes);

    // let proof_size = receipt.inner.succinct().unwrap().get_seal_bytes().len();
    // println!("{:?}", proof_size);

    let end_proof = Instant::now();
    let elapsed_proof = end_proof - start_proof;
    println!("Generating proof done");
    println!("**********************************");

    // let size = mem::size_of_val(&receipt);

    // println!("The receipt size is: {:?}", size);
    // let proof_size = receipt.inner.composite().unwrap().segments.iter().fold(0, |acc, segment| acc + segment.get_seal_bytes().len());
    // println!("Proof size is {:?}", proof_size);
    // print_size(&receipt);

    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    // let _output: u32 = receipt.journal.decode().unwrap();
    let _output: Vec<[u8; 32]> = receipt.journal.decode().unwrap();

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    println!("**********************************");
    println!("Verifying proof receipt now");
    let start_verify = Instant::now();
    
    receipt
        .verify(SHA512_HALF_TEST_ID)
        .unwrap();
    
    let end_verify = Instant::now();
    let elapsed_verify = end_verify - start_verify;
    println!("Verifying proof done");
    println!("**********************************");

    println!("\nThe output is {:?}", _output);
    println!("Elapsed time for proof generation: {:?}", elapsed_proof);
    println!("Elapsed time for proof verification: {:?}", elapsed_verify);
}
